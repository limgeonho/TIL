# Algorithm[2021.08.09]

## 1. 알고리즘

- 어떤 문제를 해결하는 절차나 방법
- 알고리즘을 표현하는 방법 = 슈도코드, 순서도
- 알고리즘의 작업량을 표현할 때는 시간복잡도로 표현

## 2. 빅오표기법(O)

- 가장 큰 영향력을 주는 n 에 대한 항 만을 표시
- 가장 큰 영향력을 주는 n 에 대한 항 만을 표시
- 최악의 경우를 계산
- 최고차항만 선택
- 계수는 생략
- 1초당 10억번 연산한다고 생각

## 3. 리스트(list)

- []

- list()

- 리스트의 인덱스를 1부터 사용하고 싶다면

  => [0] + list()

## 4. 정렬 알고리즘

- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값으로 재배열(오름차순)
- 종류
  1. 버블정렬
  2. 카운팅 정렬
  3. 선택 정렬
  4. 퀵 정렬
  5. 삽입 정렬
  6. 병합 정렬

## 5. 버블 정렬

- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- O(N^2)

```python
# 버블 정렬 알고리즘
# 앞에서부터 순차적으로 바로 다음 숫자와 비교한 뒤 큰 숫자와 작은 숫자의 순서를 교환해 나가는 알고리즘

def bubble_sort(array):
    # 처음에는 맨 마지막 까지 순환해야함 => 다음부터는 하나씩 줄여나감 : 마지막에 가장 큰 수 가 정렬되었기 때문
    for i in range(len(array)-1, 0, -1):
        # j는 마지막 인덱스 전(-1)까지만 돌면 됨 : j+1이 마지막에 위치하기 때문에
        for j in range(0, i):
            if array[j] > array[j+1]:
                array[j], array[j+1] = array[j+1], array[j]

```

## 6. 카운팅 정렬

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형시간에 정렬하는 알고리즘
- O(n+k)
- 각 원소가 몇 번씩 등장했는지 카운팅
- 카운팅해야하는 수들의 범위와 카운팅할 기본 리스트의 크기는 다를 수 있음(주의)

```python
# 카운팅 알고리즘
# 나열 된 수들의 개수를 카운팅 한 후 앞에서 부터 숫자와 해당 카운팅 횟수만큼 출력한다.
# (주의) 카운팅해야하는 array의 크기와 count리스트의 크기는 같지 않을 수 도 있다
# count리스트의 크기는 array 중 가장 큰 수 만큼 만들고 초기값을 0으로 세팅한다.

array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

# array의 최대값보다 하나 큰 수 만큼 리스트를 만든다
count = [0] * (max(array)+1)

# count리스트 안에 array에서 나온 숫자들을 +1해주면서 누적한다.
for i in range(len(array)):
    count[array[i]] += 1

# 인덱스를 해당 인덱스가 카운팅된 만큼 반복하며 출력한다.
for i in range(len(count)):
    for _ in range(count[i]):
        print(i, end=' ')

```

## 7. 완전 검색

- brute force, generate-and-test
- 모든 경우의 수를 나열하고 확인하는 방법
- 경우의 수가 작을 때 유용함

## 8. 순열

- 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열하는 것(순서O)
- 조합에서는 순서를 고려하지 않지만 순열은 순서를 고려한다.

```python
# {1, 2, 3} 으로 만들 수 있는 순열
for i1 in range(1, 4):
  for i2 in range(1, 4):
    if i2 != i1:
      for i3 in range(1, 4):
        if i3 != i1 and i3 != i2:
          print(i1, i2, i3)
```

## 9. 탐욕 알고리즘

- greedy algorithm
- 최적해를 구하는 데 사용되는 근시안적인 방법
- 선택하는 순간 마다 당시의 최적이라고 생각하는 것들을 선택해 나가는 방식
- 정렬과 관련이 높음